# Разбор задачи 5G: Счет в гипершашках

## Описание задачи

Андрей играет в гипершашки, где в каждой игре участвуют три игрока. По ходу игры каждый игрок набирает некоторое положительное целое число баллов. Если после окончания игры первый игрок набрал `a` баллов, второй — `b`, а третий `c`, то говорят, что игра закончилась со счетом `a:b:c`.

Правила игры устроены так, что в результате игры баллы любых двух игроков различаются не более чем в `k` раз.

Андрей хочет понять, сколько различных вариантов счета он сможет показать на табло, используя имеющиеся карточки с числами.

**Формат ввода:**

- Первая строка: `n` и `k` (3 ≤ n ≤ 100000, 1 ≤ k ≤ 10^9)
- Вторая строка: `n` целых чисел `x₁, x₂, ..., xₙ` (1 ≤ xᵢ ≤ 10^9)

**Формат вывода:**

- Одно целое число — количество различных вариантов счета

## Анализ решения

### Основные идеи

1. **Ограничение на соотношение баллов**: Баллы любых двух игроков различаются не более чем в `k` раз. Это означает, что если минимальный балл равен `min`, то максимальный балл не может превышать `min * k`.

2. **Сортировка и группировка**: Решение сортирует уникальные значения и для каждого значения как минимального находит все возможные значения, которые могут быть максимальными.

3. **Подсчет комбинаций**: Для каждой тройки чисел учитываются различные способы их расстановки (перестановки).

### Разбор алгоритма

#### Шаг 1: Подготовка данных

```javascript
const countMap = getMap(seq); // Подсчет количества каждого числа
const unique = [...new Set(seq)].sort((a, b) => a - b); // Уникальные числа по возрастанию
```

#### Шаг 2: Предварительный подсчет чисел с повторениями

```javascript
const summator = [];
let sum = 0;
unique.forEach((val, index) => {
  if (countMap.get(val) > 1) {
    sum++;
  }
  summator[index] = sum;
});
```

Массив `summator` содержит префиксные суммы количества чисел, которые встречаются более одного раза.

#### Шаг 3: Основной цикл подсчета

Для каждого числа `unique[l]` как минимального:

1. **Находим диапазон допустимых чисел**:

   ```javascript
   while (p < unique.length && unique[l] * k >= unique[p]) {
     p++;
   }
   const countForTwo = p - 1 - l;
   ```

   `countForTwo` — количество различных чисел в диапазоне `[unique[l], unique[l] * k]`, исключая само `unique[l]`.

2. **Случай с тремя одинаковыми числами**:

   ```javascript
   if (countMap.get(unique[l]) > 2) {
     result += 1;
   }
   ```

   Если число встречается 3 или более раз, добавляем 1 вариант (a:a:a).

3. **Случай с двумя одинаковыми числами**:

   ```javascript
   if (countMap.get(unique[l]) >= 2 && countForTwo > 0) {
     result += countForTwo * 3;
   }
   ```

   Если минимальное число встречается ≥2 раз, то для каждого другого числа в диапазоне получаем 3 варианта: (a:a:b), (a:b:a), (b:a:a).

4. **Случай с тремя разными числами**:

   ```javascript
   result += (countForTwo - 1 + 1) * (countForTwo - 1) * 3;
   ```

   Выбираем 2 числа из `countForTwo` доступных (исключая минимальное). Количество способов: C(countForTwo, 2) \* 6, где 6 — количество перестановок трех разных чисел.

5. **Дополнительные варианты с повторяющимися числами**:
   ```javascript
   const tmp = summator[p - 1] - summator[l];
   if (tmp > 0) {
     result += tmp * 3;
   }
   ```
   Учитываем случаи, где второе число встречается ≥2 раз в диапазоне.

### Сложность алгоритма

- **Временная сложность**: O(n log n) — из-за сортировки уникальных элементов
- **Пространственная сложность**: O(n) — для хранения карты подсчетов и массивов

### Ключевые техники

1. **Техника двух указателей**: Использование указателя `p` для эффективного поиска границы диапазона
2. **Префиксные суммы**: Массив `summator` для быстрого подсчета количества повторяющихся элементов в диапазоне
3. **Комбинаторика**: Правильный подсчет количества перестановок для различных случаев

## Обучающие материалы

### Необходимые знания:

1. **Комбинаторика**:

   - Размещения и сочетания
   - Подсчет перестановок с повторениями
   - Материал: "Дискретная математика" Кнут, глава о комбинаторике

2. **Техника двух указателей**:

   - Эффективный поиск в отсортированных массивах
   - Материал: "Алгоритмы: построение и анализ" Кормен, раздел о сортировке

3. **Префиксные суммы**:

   - Быстрый подсчет сумм на отрезках
   - Материал: Любой учебник по алгоритмам, раздел о структурах данных

4. **Работа с Map/HashMap**:
   - Подсчет частоты элементов
   - Материал: Документация по JavaScript Map

### Похожие задачи для тренировки:

1. Задачи на подсчет троек с ограничениями
2. Задачи на комбинаторику с повторениями
3. Задачи на технику двух указателей
4. Задачи на префиксные суммы

### Типичные ошибки:

1. Неправильный подсчет перестановок для случаев с повторениями
2. Ошибки в границах при использовании техники двух указателей
3. Забыть учесть все возможные случаи расстановки чисел
4. Переполнение при больших значениях k

## Заключение

Задача требует хорошего понимания комбинаторики и умения эффективно работать с отсортированными данными. Ключевая сложность — правильно разобрать все случаи и не допустить ошибок в подсчете перестановок.
