# Разбор задачи: Расшифровка письменности Майя

## Условие задачи

Дана строка-образец (слово) и длинная строка. Нужно найти количество подстрок в длинной строке, которые являются анаграммами данного слова.

## Входные данные

- Первая строка: два числа - длина слова-образца и длина всей строки
- Вторая строка: слово-образец
- Третья строка: строка для поиска

## Алгоритм решения

### Основная идея

Используется техника "скользящего окна" (sliding window) с подсчетом частот символов:

1. **Подготовка**: создаем словарь частот для слова-образца
2. **Скользящее окно**: проходим по строке, поддерживая окно размером с длину образца
3. **Проверка анаграммы**: для каждой позиции окна сравниваем частоты символов

### Структуры данных

```javascript
const word_dict = new Map(); // частоты символов в слове-образце
const all_dict = new Map(); // частоты символов в текущем окне
const second_dict = new Map(); // частоты символов, которые уже вышли из окна
```

### Пошаговый разбор кода

#### 1. Инициализация

```javascript
const [word_length, all_length] = data[0]
  .split(" ")
  .map((input) => parseInt(input));
const word = data[1].trim();
const s = data[2].trim();
```

- Парсим входные данные
- Получаем длины и строки

#### 2. Подсчет частот образца

```javascript
[...word].forEach((element) => {
  word_dict.set(element, (word_dict.get(element) ?? 0) + 1);
});
```

- Создаем Map с частотами каждого символа в слове-образце

#### 3. Основной цикл - скользящее окно

```javascript
for (let i = 0; i < all_length; i++) {
  // Добавляем новый символ в окно
  all_dict.set(s[i], (all_dict.get(s[i]) ?? 0) + 1);

  // Убираем символ, который вышел из окна
  if (i - word_length >= 0) {
    second_dict.set(
      s[i - word_length],
      (second_dict.get(s[i - word_length]) ?? 0) + 1
    );
  }
```

#### 4. Проверка на анаграмму

```javascript
let is_candidate = true;
for (let [key, val] of word_dict) {
  let cf = second_dict.get(key);
  if (cf === undefined) cf = 0;
  let ca = all_dict.get(key);
  if (ca === undefined || ca - cf != val) {
    is_candidate = false;
    break;
  }
}
```

**Ключевая логика**:

- `ca` - общее количество символа `key` от начала до текущей позиции
- `cf` - количество символа `key`, которое уже вышло из окна
- `ca - cf` - количество символа `key` в текущем окне
- Сравниваем `ca - cf` с требуемым количеством `val` из образца

## Сложность алгоритма

- **Временная сложность**: O(n × k), где n - длина строки, k - количество уникальных символов в образце
- **Пространственная сложность**: O(k), где k - количество уникальных символов

## Пример работы

Пусть:

- Слово-образец: "abc" (длина 3)
- Строка: "abcab"

**Шаг 1** (i=0): окно "a"

- all_dict: {a: 1}
- second_dict: {}
- Текущее окно: "a" - не анаграмма (недостаточно символов)

**Шаг 2** (i=1): окно "ab"

- all_dict: {a: 1, b: 1}
- second_dict: {}
- Текущее окно: "ab" - не анаграмма (недостаточно символов)

**Шаг 3** (i=2): окно "abc"

- all_dict: {a: 1, b: 1, c: 1}
- second_dict: {}
- Текущее окно: "abc" - анаграмма! ✓

**Шаг 4** (i=3): окно "bca"

- all_dict: {a: 2, b: 1, c: 1}
- second_dict: {a: 1}
- Текущее окно: a(2-1)=1, b(1-0)=1, c(1-0)=1 - анаграмма! ✓

## Возможные оптимизации

1. Можно использовать один Map вместо двух, удаляя элементы при выходе из окна
2. Для ASCII символов можно использовать массив вместо Map
3. Можно добавить раннее прерывание, если в строке недостаточно нужных символов

## Альтернативные подходы

1. **Наивный подход**: для каждой позиции создавать новый Map - O(n × m)
2. **Сортировка**: сортировать каждое окно и сравнивать - O(n × m log m)
3. **Хеширование**: использовать полиномиальный хеш для быстрого сравнения
