# Разбор задачи: Продажи

## Условие задачи

Задача "Продажи" требует обработать данные о продажах товаров различным покупателям. Входные данные содержат строки в формате: `покупатель товар количество`. Необходимо сгруппировать данные по покупателям и товарам, суммируя количество одинаковых товаров для каждого покупателя.

## Анализ решения

### Основная идея

Решение использует сортировку входных данных и последовательную обработку для группировки по покупателям и товарам.

### Пошаговый разбор алгоритма

#### 1. Сортировка данных

```javascript
data.sort();
```

- Сортируем все строки лексикографически
- Это обеспечивает группировку записей одного покупателя рядом
- Внутри группы покупателя записи одного товара также будут рядом

#### 2. Инициализация переменных

```javascript
let str_result = "";
let current_customer = false;
let current_item = false;
let counter = 0;
```

- `str_result` - строка для накопления результата
- `current_customer` - текущий обрабатываемый покупатель
- `current_item` - текущий обрабатываемый товар
- `counter` - счетчик количества текущего товара

#### 3. Основной цикл обработки

```javascript
for (let i = 0; i < data.length; i++) {
    let [customer, item, count] = data[i].trim().split(" ");
```

- Разбираем каждую строку на компоненты: покупатель, товар, количество

#### 4. Обработка смены покупателя

```javascript
if (customer != current_customer) {
  if (current_customer != false) {
    str_result += counter + "\n";
    counter = 0;
    current_item = false;
  }
  str_result += customer + ":\n";
  current_customer = customer;
}
```

- При смене покупателя:
  - Записываем количество предыдущего товара (если есть)
  - Сбрасываем счетчик и текущий товар
  - Добавляем имя нового покупателя с двоеточием

#### 5. Обработка смены товара

```javascript
if (item != current_item) {
  if (current_item != false) {
    str_result += counter + "\n";
  }
  str_result += item + " ";
  current_item = item;
  counter = parseInt(count);
} else {
  counter += parseInt(count);
}
```

- При смене товара:
  - Записываем количество предыдущего товара (если есть)
  - Начинаем новый товар с его количеством
- При том же товаре:
  - Суммируем количество к текущему счетчику

#### 6. Завершение обработки

```javascript
if (counter > 0) {
  str_result += counter + "\n";
}
```

- Записываем количество последнего товара

## Пример работы

### Входные данные:

```
Иванов молоко 2
Петров хлеб 1
Иванов хлеб 1
Иванов молоко 3
Петров молоко 2
```

### После сортировки:

```
Иванов молоко 2
Иванов молоко 3
Иванов хлеб 1
Петров молоко 2
Петров хлеб 1
```

### Выходные данные:

```
Иванов:
молоко 5
хлеб 1
Петров:
молоко 2
хлеб 1
```

## Сложность алгоритма

- **Временная сложность**: O(n log n) - из-за сортировки
- **Пространственная сложность**: O(n) - для хранения результата

## Особенности реализации

### Преимущества:

1. **Простота**: Использование сортировки упрощает логику группировки
2. **Читаемость**: Код легко понять и отладить
3. **Корректность**: Обрабатывает все граничные случаи

### Недостатки:

1. **Производительность**: Сортировка может быть избыточной для некоторых случаев
2. **Память**: Накопление результата в строке может быть неэффективно для больших данных

## Альтернативные подходы

### Использование Map/Object:

```javascript
const orders = {};
for (const line of data) {
  const [customer, item, count] = line.split(" ");
  if (!orders[customer]) orders[customer] = {};
  if (!orders[customer][item]) orders[customer][item] = 0;
  orders[customer][item] += parseInt(count);
}
```

Этот подход имеет временную сложность O(n), но требует дополнительной сортировки для вывода в лексикографическом порядке.

## Заключение

Решение корректно и эффективно решает поставленную задачу. Использование сортировки делает код простым и понятным, хотя и добавляет логарифмический фактор к временной сложности. Для большинства практических случаев такой подход является оптимальным балансом между простотой реализации и производительностью.
