# Задача 117. Охрана - Разбор решения

## Условие задачи

На секретной военной базе работает N охранников. Сутки поделены на 10000 равных промежутков времени, и известно когда каждый из охранников приходит на дежурство и уходит с него. Например, если охранник приходит в 5, а уходит в 8, то значит, что он был в 6, 7 и 8-ой промежуток (а в 5-и нет!).

**Важное условие**: для данного набора охранников объект охраняется в любой момент времени хотя бы одним охранником и удаление любого из них приводит к появлению промежутка времени, когда объект не охраняется.

## Формат ввода

- В первой строке: K (1 ≤ K ≤ 100) — количество тестов в файле
- Каждый тест начинается с числа N (1 ≤ N ≤ 10000), за которым следует N пар неотрицательных целых чисел A и B — время прихода на дежурство и ухода (0 ≤ A ≤ B ≤ 10000) соответствующего охранника

## Формат вывода

Выведите K строк, где в M-ой строке находится слово "Accepted", если M-ый набор охранников удовлетворяет описанным выше условиям. В противном случае выведите "Wrong Answer".

## Алгоритм решения

### Основная идея

Задача сводится к проверке двух условий:

1. **Полное покрытие**: объект должен быть охраняем в каждый момент времени от 0 до 10000
2. **Критичность каждого охранника**: удаление любого охранника должно нарушать покрытие

### Подход через события

Используем алгоритм "sweep line" (сканирующая прямая):

1. **Создание событий**: Для каждого охранника создаем два события:

   - `[start, -1, index]` — охранник приходит (флаг -1)
   - `[end, 1, index]` — охранник уходит (флаг 1)

2. **Сортировка событий**: Сортируем по времени, при равном времени сначала обрабатываем приходы (-1), потом уходы (1)

3. **Обработка событий**: Проходим по отсортированным событиям и отслеживаем:
   - `current` — множество охранников, находящихся на дежурстве в данный момент
   - `good` — множество охранников, которые были единственными на дежурстве в какой-то момент

### Ключевые проверки

```javascript
// 1. Проверка полного покрытия от 0 до 10000
if (events[0][0] !== 0 || events[events.length - 1][0] < 10000) {
    return false;
}

// 2. Проверка отсутствия пробелов в покрытии
if (event[0] !== 0 && current.size === 0) {
    goodFlag = false;
    break;
}

// 3. Отметка критичных охранников
if (current.size === 1 && event[0] !== prevTime) {
    for (const val of current) {
        good.add(val);
    }
}

// 4. Финальная проверка
return goodFlag && good.size === N;
```

### Пример работы алгоритма

Для входных данных:

```
3 0 3000 2500 7000 2700 10000
```

События после сортировки:

```
[0, -1, 0]     // охранник 0 приходит в 0
[2500, -1, 1]  // охранник 1 приходит в 2500
[2700, -1, 2]  // охранник 2 приходит в 2700
[3000, 1, 0]   // охранник 0 уходит в 3000
[7000, 1, 1]   // охранник 1 уходит в 7000
[10000, 1, 2]  // охранник 2 уходит в 10000
```

Обработка:

- В момент 0-2500: только охранник 0 → добавляем в `good`
- В момент 2500-2700: охранники 0,1 → никого не добавляем
- В момент 2700-3000: охранники 0,1,2 → никого не добавляем
- В момент 3000-7000: только охранник 2 → добавляем в `good`
- В момент 7000-10000: только охранник 2 → уже в `good`

Результат: `good.size = 2`, но `N = 3` → "Wrong Answer"

## Оптимизации для прохождения по памяти

1. **Потоковая обработка**: Обрабатываем каждый тест сразу при чтении, не накапливая все данные
2. **Эффективный парсинг**: Используем простой `split(' ')` вместо цепочки операций
3. **Минимизация промежуточных структур**: Избегаем создания лишних массивов и объектов

## Сложность

- **Время**: O(N log N) на каждый тест из-за сортировки событий
- **Память**: O(N) для хранения событий и множеств

Эта оптимизация позволяет решению проходить ограничения по памяти (64 МБ) и времени (4 секунды).
