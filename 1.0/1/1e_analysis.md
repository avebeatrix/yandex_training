## Идея решения

Основная идея заключается в том, чтобы определить, сколько квартир находится на каждом этаже, а затем использовать эту информацию для вычисления подъезда и этажа нужной квартиры.

Мы не знаем точное количество квартир на каждом этаже, но можем перебрать все возможные варианты и проверить их на соответствие условиям задачи.

Эта задача иллюстрирует важный принцип решения алгоритмических задач: иногда перебор с проверкой является наиболее надежным способом решения, особенно когда точное решение найти сложно из-за множества неизвестных параметров.

## Алгоритм решения:

1. Создаем функцию `getEntranceAndFloor`, которая по номеру квартиры, количеству квартир на этаже и количеству этажей в доме определяет подъезд и этаж.

2. Создаем функцию `check`, которая проверяет, соответствует ли наше предположение о количестве квартир на этаже известным данным о второй квартире.

3. Перебираем возможные значения количества квартир на этаже (от 1 до максимального номера квартиры из входных данных).

4. Для каждого подходящего варианта определяем подъезд и этаж первой квартиры.

5. Если получаем несколько разных ответов для подъезда или этажа, то заменяем соответствующее значение на 0, как требуется по условию.

6. Если ни одного подходящего варианта не найдено, возвращаем "-1 -1".

## Разбор ключевых функций в решении:

### 1. Функция `getEntranceAndFloor`

```javascript
const getEntranceAndFloor = (flatno, flatsonfloor, floors) => {
  let floorsbefore = Math.floor((flatno - 1) / flatsonfloor);
  let entrance = Math.floor(floorsbefore / floors) + 1;
  let floor = (floorsbefore % floors) + 1;
  return [entrance, floor];
};
```

Эта функция определяет подъезд и этаж по номеру квартиры:

- `floorsbefore` - количество полных этажей до нужной квартиры
- `entrance` - номер подъезда (каждый подъезд содержит `floors` этажей)
- `floor` - номер этажа внутри подъезда

### 2. Функция `check`

```javascript
const check = (k1, m, k2, p2, n2, flatsonfloor) => {
  const [entrance2, floor2] = getEntranceAndFloor(k2, flatsonfloor, m);
  if (entrance2 == p2 && floor2 == n2) {
    return getEntranceAndFloor(k1, flatsonfloor, m);
  }
  return [-1, -1];
};
```

Функция проверяет, соответствует ли предполагаемое количество квартир на этаже известным данным о второй квартире. Если да, то вычисляет подъезд и этаж для первой квартиры.

### 3. Функция `findSolutions`

```javascript
const findSolutions = (k1, m, k2, p2, n2) => {
  let ent = -1;
  let floor = -1;
  let goodFlag = false;
  // Оптимизация: ограничиваем перебор максимальным номером квартиры
  const maxFlats = Math.max(k1, k2);
  for (let i = 1; i <= maxFlats; i++) {
    const [nent, nfloor] = check(k1, m, k2, p2, n2, i);
    if (nent != -1) {
      goodFlag = true;
      if (ent == -1) {
        ent = nent;
        floor = nfloor;
      } else if (ent != nent && ent != 0) {
        ent = 0;
      } else if (floor != nfloor && floor != 0) {
        floor = 0;
      }
    }
  }
  if (goodFlag) {
    return ent + " " + floor;
  } else {
    return "-1 -1";
  }
};
```

Функция перебирает возможные значения количества квартир на этаже и находит все подходящие решения. Если для подъезда или этажа получаем разные значения, то заменяем соответствующее значение на 0.

## Анализ сложности алгоритма

### Временная сложность: O(max(k1, k2))

- **Основной цикл**: Перебираем все возможные значения количества квартир на этаже от 1 до максимального номера квартиры
- **Оптимизация**: Используем `Math.max(k1, k2)` вместо фиксированного значения 1,000,000
- **Операции внутри цикла**:
  - Функция `check()` выполняется за O(1) - константное время
  - Функция `getEntranceAndFloor()` выполняется за O(1) - только арифметические операции
  - Проверки и обновления переменных - O(1)

**Итоговая временная сложность: O(max(k1, k2))**

### Пространственная сложность: O(1)

- Используется фиксированное количество переменных независимо от размера входных данных
- Не создаются дополнительные структуры данных, размер которых зависит от входа
- Все переменные занимают константное количество памяти
