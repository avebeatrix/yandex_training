# Разбор задачи: Пробежки по Манхэттену

## Условие задачи

Миша живет в Нью-Манхэттене и делает пробежки по городу. Дороги устроены в виде прямоугольной сетки координат. Миша начинает пробежку из дома в точке (0, 0) и каждую минуту перемещается на один квартал в любом направлении (север, юг, восток, запад).

У Миши есть навигатор, который каждые `t` минут сообщает его координаты с погрешностью не более `d` кварталов по манхэттенскому расстоянию.

**Задача**: определить все возможные позиции Миши через `t × n` минут после начала пробежки.

## Визуализация проблемы

### Манхэттенское расстояние

```
Манхэттенское расстояние между (x₁,y₁) и (x₂,y₂) = |x₁-x₂| + |y₁-y₂|

Пример: расстояние от (0,0) до (2,1) = |0-2| + |0-1| = 2 + 1 = 3

     -3  -2  -1   0   1   2   3
   ┌───┬───┬───┬───┬───┬───┬───┐
 3 │   │   │   │ ● │   │   │   │
   ├───┼───┼───┼───┼───┼───┼───┤
 2 │   │   │ ● │ ● │ ● │   │   │
   ├───┼───┼───┼───┼───┼───┼───┤
 1 │   │ ● │ ● │ ● │ ● │ ● │   │
   ├───┼───┼───┼───┼───┼───┼───┤
 0 │ ● │ ● │ ● │ S │ ● │ ● │ ● │  S = старт, ● = достижимые за 3 шага
   ├───┼───┼───┼───┼───┼───┼───┤
-1 │   │ ● │ ● │ ● │ ● │ ● │   │
   ├───┼───┼───┼───┼───┼───┼───┤
-2 │   │   │ ● │ ● │ ● │   │   │
   ├───┼───┼───┼───┼───┼───┼───┤
-3 │   │   │   │ ● │   │   │   │
   └───┴───┴───┴───┴───┴───┴───┘
```

## Ключевая идея: Поворот системы координат

### Проблема с обычными координатами

В декартовых координатах область достижимости - это ромб, что усложняет вычисления.

### Решение: Поворот на 45°

Используем преобразование:

- `u = x + y` (новая "горизонтальная" координата)
- `v = x - y` (новая "вертикальная" координата)

### Визуализация поворота координат

```
Исходная система (x,y):          Повернутая система (u,v):
Ромб |x|+|y|≤1                   Квадрат max(|u|,|v|)≤1

     y                               v
     ↑                               ↑
     │   ●                           │ ● ● ●
     │ ● S ●                         │ ● S ●
     │   ●                           │ ● ● ●
     └─────→ x                       └─────→ u

Точки:                           Точки в (u,v):
(0,1) → u=0+1=1, v=0-1=-1       (1,-1), (1,0), (1,1)
(1,0) → u=1+0=1, v=1-0=1        (0,-1), (0,0), (0,1)
(0,0) → u=0+0=0, v=0-0=0        (-1,-1), (-1,0), (-1,1)
(-1,0)→ u=-1+0=-1, v=-1-0=-1
(0,-1)→ u=0+(-1)=-1, v=0-(-1)=1

Ромб становится квадратом!
```

### Математическое обоснование

В новых координатах:

- Манхэттенское расстояние `|x₁-x₂| + |y₁-y₂|` превращается в чебышевское `max(|u₁-u₂|, |v₁-v₂|)`
- Область достижимости за `t` шагов - квадрат `[-t, t] × [-t, t]`

## Пошаговый разбор алгоритма

### 1. Функция `extend(rect, d)`

```javascript
const extend = (rect, d) => {
  const [minPlus, maxPlus, minMinus, maxMinus] = rect;
  return [minPlus - d, maxPlus + d, minMinus - d, maxMinus + d];
};
```

**Назначение**: Расширяет прямоугольник на расстояние `d` во все стороны.

### 2. Функция `intersect(rect1, rect2)`

```javascript
const intersect = (rect1, rect2) => {
  let ans = [
    Math.max(rect1[0], rect2[0]), // максимум левых границ
    Math.min(rect1[1], rect2[1]), // минимум правых границ
    Math.max(rect1[2], rect2[2]), // максимум нижних границ
    Math.min(rect1[3], rect2[3]), // минимум верхних границ
  ];
  return ans;
};
```

**Визуализация пересечения**:

```
rect1:          rect2:          Пересечение:

┌─────────┐     ┌─────────┐     ┌─────────┐
│         │     │    ┌────┼──┐  │    ┌────┤
│    A    │  ∩  │    │ B  │  │= │    │ A∩B│
│         │     │    └────┼──┘  │    └────┤
└─────────┘     └─────────┘     └─────────┘
```

### 3. Основной алгоритм - пошаговый пример

Рассмотрим пример: `t=2, d=1, n=2`
Данные навигатора: `(1,1)` и `(2,0)`

#### Шаг 0: Инициализация

```javascript
let posRect = [0, 0, 0, 0]; // Точка (0,0) в координатах (u,v)
```

```
Начальная позиция (0,0):
  v
  ↑
  │
  │   ●  ← (u=0, v=0)
  │
  └─────→ u
```

#### Шаг 1: Первое измерение навигатора

```javascript
// 1. Расширяем область на t=2 (возможное перемещение за 2 минуты)
posRect = extend([0, 0, 0, 0], 2); // [-2, 2, -2, 2]
```

```
После расширения на 2:
  v
  ↑
2 │ ┌─────────┐
1 │ │         │
0 │ │    ●    │  ← исходная позиция (0,0)
-1│ │         │
-2│ └─────────┘
  └─────────────→ u
  -2 -1 0 1 2
```

```javascript
// 2. Навигатор показывает (1,1) с погрешностью d=1
const [navX, navY] = [1, 1];
// Преобразуем в новые координаты: u = x+y = 2, v = x-y = 0
let navRect = extend([2, 2, 0, 0], 1); // [1, 3, -1, 1]
```

```
Область навигатора (1,1) ± 1:
Точка (1,1) в координатах (u,v): u=1+1=2, v=1-1=0
Расширяем на d=1: [2-1, 2+1, 0-1, 0+1] = [1, 3, -1, 1]

  v
  ↑
1 │   ┌─────┐
0 │   │  ●  │  ← центр (u=2, v=0) соответствует (x=1, y=1)
-1│   └─────┘
  └─────────→ u
    1 2 3
```

```javascript
// 3. Пересекаем области
posRect = intersect([-2, 2, -2, 2], [1, 3, -1, 1]); // [1, 2, -1, 1]
```

```
Пересечение областей:
intersect([-2, 2, -2, 2], [1, 3, -1, 1]) = [1, 2, -1, 1]
```

#### Шаг 2: Второе измерение навигатора

```javascript
// 1. Расширяем на t=2
posRect = extend([1, 2, -1, 1], 2); // [-1, 4, -3, 3]
```

```javascript
// 2. Навигатор показывает (2,0) с погрешностью d=1
const [navX, navY] = [2, 0];
// u = x+y = 2, v = x-y = 2
let navRect = extend([2, 2, 2, 2], 1); // [1, 3, 1, 3]
```

```javascript
// 3. Финальное пересечение
posRect = intersect([-1, 4, -3, 3], [1, 3, 1, 3]); // [1, 3, 1, 3]
```

### 4. Обратное преобразование координат

```javascript
for (let xPlusY = posRect[0]; xPlusY < posRect[1] + 1; xPlusY++) {
  for (let xMinusY = posRect[2]; xMinusY < posRect[3] + 1; xMinusY++) {
    if ((xPlusY + xMinusY) % 2 == 0) {
      const x = (xPlusY + xMinusY) / 2;
      const y = xPlusY - x;
      points.push(x + " " + y);
    }
  }
}
```

**Почему проверка четности?**

```
u = x + y  (в коде это xPlusY)
v = x - y  (в коде это xMinusY)

Из кода:
x = (xPlusY + xMinusY) / 2 = (u + v) / 2
y = xPlusY - x = u - x = u - (u + v)/2 = (2u - u - v)/2 = (u - v) / 2

Проверка: u + v = (x+y) + (x-y) = 2x
Для целых x нужно, чтобы (u + v) было четным!
```

**Пример обратного преобразования**:

```
posRect = [1, 3, 1, 3]

u=1, v=1: (1+1)%2=0 ✓  x=(1+1)/2=1, y=1-1=0  ⟹  (1,0)
u=1, v=2: (1+2)%2=1 ✗  пропускаем
u=1, v=3: (1+3)%2=0 ✓  x=(1+3)/2=2, y=1-2=-1 ⟹  (2,-1)
u=2, v=1: (2+1)%2=1 ✗  пропускаем
u=2, v=2: (2+2)%2=0 ✓  x=(2+2)/2=2, y=2-2=0  ⟹  (2,0)
u=2, v=3: (2+3)%2=1 ✗  пропускаем
u=3, v=1: (3+1)%2=0 ✓  x=(3+1)/2=2, y=3-2=1  ⟹  (2,1)
u=3, v=2: (3+2)%2=1 ✗  пропускаем
u=3, v=3: (3+3)%2=0 ✓  x=(3+3)/2=3, y=3-3=0  ⟹  (3,0)

Проверим несколько точек:
(1,0): u=1+0=1, v=1-0=1 ✓
(2,-1): u=2+(-1)=1, v=2-(-1)=3 ✓
(2,0): u=2+0=2, v=2-0=2 ✓
(2,1): u=2+1=3, v=2-1=1 ✓
(3,0): u=3+0=3, v=3-0=3 ✓
```

**Итоговые точки**: (1,0), (2,-1), (2,0), (2,1), (3,0)

## Детальный анализ сложности

### Временная сложность

- **Основной цикл**: O(n) - обработка n измерений навигатора
- **Генерация результата**: O(S), где S - площадь итоговой области
- **Общая сложность**: O(n + S)

### Пространственная сложность

- **Промежуточные данные**: O(1) - только координаты прямоугольника
- **Результат**: O(S) - список всех возможных позиций
- **Общая сложность**: O(S)

### Оценка размера области S

В худшем случае (без ограничений навигатора):

- После n измерений область может иметь размер до (2×t×n)²
- S = O((t×n)²)

В реальности ограничения навигатора значительно уменьшают S.

## Альтернативные подходы и их недостатки

### 1. Прямое моделирование

```python
# Псевдокод
def simulate_all_paths(t, n):
    paths = [[(0,0)]]  # все возможные пути
    for step in range(t * n):
        new_paths = []
        for path in paths:
            x, y = path[-1]
            # добавляем 4 возможных направления
            for dx, dy in [(0,1), (0,-1), (1,0), (-1,0)]:
                new_paths.append(path + [(x+dx, y+dy)])
        paths = new_paths
    return paths
```

**Проблема**: Экспоненциальная сложность O(4^(t×n))

### 2. Динамическое программирование

```python
# Псевдокод
def dp_approach(t, n):
    reachable = {(0,0): True}
    for measurement in range(n):
        # расширяем множество на t шагов
        new_reachable = {}
        for (x, y) in reachable:
            for dx in range(-t, t+1):
                for dy in range(-t, t+1):
                    if abs(dx) + abs(dy) <= t:
                        new_reachable[(x+dx, y+dy)] = True
        # применяем ограничения навигатора
        reachable = filter_by_navigator(new_reachable, nav_data[measurement])
    return reachable
```

**Проблема**: Может потребовать O((t×n)²) памяти для хранения множества

### 3. Геометрический подход (текущее решение)

**Преимущества**:

- Константная память для представления области
- Линейное время обработки измерений
- Элегантное использование поворота координат

## Математические детали

### Поворот системы координат

Преобразование `(x,y) → (x+y, x-y)` можно записать в матричном виде:

```
[u]   [1  1] [x]
[v] = [1 -1] [y]
```

Обратное преобразование:

```
[x]   [1/2  1/2] [u]   x = (u + v) / 2
[y] = [1/2 -1/2] [v] → y = (u - v) / 2

Но в коде используется другая формула:
x = (u + v) / 2
y = u - x = u - (u + v)/2 = (u - v) / 2
```

### Свойства преобразования

1. **Сохранение решетки**: Целые точки переходят в точки с целыми координатами одинаковой четности
2. **Преобразование расстояний**: Манхэттенское → Чебышевское
3. **Геометрия**: Ромбы → Квадраты

### Инвариант четности

В координатах (u,v):

- u + v = 2x всегда четно
- u - v = 2y всегда четно
- Поэтому u и v имеют одинаковую четность

## Практические соображения

### Обработка граничных случаев

1. **n = 0**: Возвращаем только (0,0)
2. **d = 0**: Навигатор абсолютно точен
3. **Большие t**: Область может стать очень большой

### Оптимизации

1. **Ранний выход**: Если область пуста после пересечения
2. **Проверка валидности**: Убедиться, что min ≤ max для всех координат
3. **Целочисленная арифметика**: Избегать операций с плавающей точкой

## Заключение

Решение демонстрирует мощь геометрического подхода к алгоритмическим задачам:

1. **Ключевая идея**: Поворот координат превращает сложную геометрию (ромбы) в простую (квадраты)
2. **Эффективность**: Линейное время по количеству измерений, оптимальное использование памяти
3. **Элегантность**: Компактный код, ясная логика

Этот подход можно обобщить на другие задачи с манхэттенской метрикой, где требуется отслеживать области достижимости с ограничениями.
