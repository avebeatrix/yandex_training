# Разбор задачи: Инопланетный геном

## Условие задачи

Геном жителей системы Тау Кита содержит 26 видов оснований (A-Z). Степень близости одного генома к другому - это количество пар соседних оснований первого генома, которые встречаются во втором геноме.

**Задача:** Определить степень близости первого генома ко второму.

**Пример:**

- Первый геном: `ABBACAB`
- Второй геном: `BCABB`
- Ответ: `4`

## Анализ примера

Разберем пример пошагово:

### Пары соседних оснований в первом геноме:

- `AB` (позиции 0-1)
- `BB` (позиции 1-2)
- `BA` (позиции 2-3)
- `AC` (позиции 3-4)
- `CA` (позиции 4-5)
- `AB` (позиции 5-6)

### Пары соседних оснований во втором геноме:

- `BC` (позиции 0-1)
- `CA` (позиции 1-2)
- `AB` (позиции 2-3)
- `BB` (позиции 3-4)

### Подсчет совпадений:

Проверяем, какие пары из первого генома встречаются во втором:

- `AB` ✓ (есть во втором геноме)
- `BB` ✓ (есть во втором геноме)
- `BA` ✗ (нет во втором геноме)
- `AC` ✗ (нет во втором геноме)
- `CA` ✓ (есть во втором геноме)
- `AB` ✓ (есть во втором геноме, считается снова)

**Итого:** 4 совпадения

## Алгоритм решения

### Подход

1. Извлечь все пары соседних символов из второго генома и сохранить в множество (Set)
2. Пройти по всем парам соседних символов первого генома
3. Для каждой пары проверить, есть ли она в множестве пар второго генома
4. Подсчитать количество найденных пар

### Временная сложность

- **O(n + m)**, где n - длина первого генома, m - длина второго генома
- Построение множества: O(m)
- Проход по первому геному: O(n)
- Поиск в множестве: O(1) для каждой операции

### Пространственная сложность

- **O(m)** для хранения множества пар из второго генома

## Разбор кода

```javascript
const getResult = (data) => {
  const first = [...data[0].trim()]; // Преобразуем первую строку в массив символов
  const second = [...data[1].trim()]; // Преобразуем вторую строку в массив символов
  const secondSet = new Set(); // Множество для пар из второго генома
  let result = 0; // Счетчик совпадений

  // Заполняем множество парами из второго генома
  for (i = 1; i < second.length; i++) {
    secondSet.add(second[i - 1] + second[i]);
  }

  // Проверяем пары из первого генома
  for (i = 1; i < first.length; i++) {
    if (secondSet.has(first[i - 1] + first[i])) {
      result++;
    }
  }

  return result;
};
```

### Ключевые моменты реализации:

1. **Использование Set**: Обеспечивает быстрый поиск O(1) и автоматически исключает дубликаты пар во втором геноме

2. **Конкатенация строк**: `second[i - 1] + second[i]` создает строку из двух соседних символов

3. **Два прохода**:

   - Первый проход собирает все пары из второго генома
   - Второй проход проверяет пары из первого генома

4. **Подсчет всех вхождений**: Если пара встречается несколько раз в первом геноме, каждое вхождение учитывается отдельно

## Возможные оптимизации

Код уже достаточно оптимален для данной задачи. Единственное замечание - отсутствует объявление переменной `i` (должно быть `let i` или `const i`), но это не влияет на корректность работы в Node.js.

## Альтернативные подходы

1. **Использование Map с подсчетом**: Если нужно учитывать количество вхождений пар во втором геноме
2. **Прямой поиск**: Для каждой пары из первого генома искать во втором (менее эффективно - O(n\*m))

## Заключение

Решение эффективно использует структуру данных Set для быстрого поиска и имеет оптимальную временную сложность O(n + m).
